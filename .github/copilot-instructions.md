# SupportDesk AI Guide

## Architecture snapshot

- React 18 + TypeScript frontend under `src/`, wired through `App.tsx` which swaps dashboards in `LayoutModern` based on `currentPage` and logged-in role.
- Singleton services (see `src/services/*`) wrap all side effects; the frontend never reaches straight into fetch/localStorage—rely on `Service.getInstance()` patterns.
- Express/Mongoose backend lives in `backend/server.js`, exposes `/api/**` endpoints, issues `mock_token_<id>` for email/password logins and JWTs for Google OAuth; data models are in `backend/models/` and ticket numbers are generated by `backend/utils/ticketIdGenerator.js`.

## Environment & commands

- Install dependencies in both roots: `npm install` (frontend) and `cd backend && npm install`; backend uses its own `.env` loaded via `dotenv.config({ path: './.env' })`.
- Dev loop: start MongoDB, then `cd backend && npm run dev`; in another shell `npm run dev` (or run `start-system.bat` to launch both with delays).
- Health checks: run `node test-connection.js` from the project root to verify `/api/health`, `/api/auth/login`, and `/api/users` before debugging UI failures.

## Data & services

- `ApiService` prepends `import.meta.env.VITE_API_BASE_URL + '/api'`; set `VITE_API_BASE_URL=http://localhost:3002` (no trailing `/api`).
- `AuthService` normalizes `_id` → `id`, caches `auth_token`/`user_data`, and exposes Google helpers—extend auth flows here so `App.tsx` stays declarative.
- `TicketService` first attempts backend calls, then falls back to `localStorage` mocks (`tickets` key); when adding fields ensure both code paths update `MOCK_TICKETS` and `saveTicketsToStorage()`.
- Use `ToastService` + `ToastContainer` for UX feedback instead of ad-hoc toasts; notifications auto-dismiss unless you supply `duration`.

## UI patterns

- Navigation lives in `LayoutModern.tsx`: each nav item has an `id` string that must match `App.tsx`'s `renderCurrentPage` switch; add new pages by updating both.
- Ticket views (`AgentDashboard`, `TicketDetail`, etc.) listen to `AppState`'s `onTicketOpen` so notification clicks deep-link; fire `AppState.getInstance().openTicket(id)` from new surfaces to keep parity.
- Styling is Tailwind-heavy with dark-mode overrides in `src/index.css`; prefer utility classes and reuse helpers like `.btn-primary`/`.priority-*`.

## Notifications & messaging

- `NotificationPollingService` polls every 10s and stores state in localStorage (`app_notifications`); remember to mark read/clear via the service or you will leak duplicate polls.
- Email flows exist in both layers: frontend `src/services/emailService.ts` is a mock for UI previews, while backend `backend/emailService.js` actually sends via nodemailer/SendGrid—know which one you're touching.
- Live chat / AI assist uses `OpenAIService`; set `VITE_OPENAI_API_KEY` before enabling, otherwise it returns a friendly error string.

## Backend specifics

- `server.js` wires OAuth via `backend/services/googleOAuthHandler.js`, expecting `GOOGLE_CLIENT_ID/SECRET` and `JWT_SECRET`; Google logins surface as JWTs that `verifyAdmin` accepts.
- Ticket creation routes call `TicketIdGenerator.generateShortId`; anytime you seed tickets manually, set `ticketNumber` to match `TKT-#####` to keep the counter consistent.
- Admin-only routes rely on the `verifyAdmin` middleware—pass the frontend token as `Authorization: Bearer mock_token_<id>` or real JWT when writing tests/tools.

## Testing & tooling

- Playwright specs live in `tests/`; they assume the seeded demo accounts (`admin@company.com`, `agent@company.com`, `customer@email.com` / `password123`) exist—run `cd backend && npm run reset-users` if they drift.
- Visual regression output under `test-results/` comes from Playwright; clean it before committing large changes.
- Lint/typecheck via `npm run lint` and `npm run typecheck`; align new TS interfaces with `src/types/index.ts` to keep static checks green.

## When extending

- Add new API calls in `ApiService` first, then call them from domain services (auth/ticket/email) so offline fallbacks stay centralized.
- Respect role-based visibility: dashboards filter content by `user.role`, and nav items declare allowed roles—mirror those checks in new components.
- Whenever you persist new fields, update both the Mongo schemas and the localStorage mirrors (`Ticket`, `User` shapes) plus adjust Playwright expectations.

Let me know if any section feels thin or if other workflows should be captured so we can tune this guide further.
